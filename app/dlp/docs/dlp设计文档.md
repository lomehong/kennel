# ç»ˆç«¯æ•°æ®é˜²æ³„æ¼(DLP)ç³»ç»Ÿè®¾è®¡æ–‡æ¡£

## æ–‡æ¡£ä¿¡æ¯
- **ç‰ˆæœ¬**: v2.0
- **åˆ›å»ºæ—¥æœŸ**: 2024å¹´
- **æœ€åæ›´æ–°**: 2024å¹´
- **æ–‡æ¡£çŠ¶æ€**: è®¾è®¡é˜¶æ®µ
- **è´Ÿè´£äºº**: å¼€å‘å›¢é˜Ÿ

## ç›®å½•
1. [é¡¹ç›®æ¦‚è¿°](#1-é¡¹ç›®æ¦‚è¿°)
2. [éœ€æ±‚åˆ†æ](#2-éœ€æ±‚åˆ†æ)
3. [ç³»ç»Ÿæ¶æ„è®¾è®¡](#3-ç³»ç»Ÿæ¶æ„è®¾è®¡)
4. [æ ¸å¿ƒæ¨¡å—è®¾è®¡](#4-æ ¸å¿ƒæ¨¡å—è®¾è®¡)
5. [å®‰å…¨è®¾è®¡](#5-å®‰å…¨è®¾è®¡)
6. [æ€§èƒ½ä¼˜åŒ–](#6-æ€§èƒ½ä¼˜åŒ–)
7. [éƒ¨ç½²æ–¹æ¡ˆ](#7-éƒ¨ç½²æ–¹æ¡ˆ)
8. [è¿ç»´ç®¡ç†](#8-è¿ç»´ç®¡ç†)
9. [æµ‹è¯•éªŒè¯](#9-æµ‹è¯•éªŒè¯)
10. [é£é™©è¯„ä¼°](#10-é£é™©è¯„ä¼°)
11. [åˆè§„æ€§è®¾è®¡](#11-åˆè§„æ€§è®¾è®¡)
12. [é™„å½•](#12-é™„å½•)

---

## 1. é¡¹ç›®æ¦‚è¿°

### 1.1 é¡¹ç›®èƒŒæ™¯
éšç€ä¼ä¸šæ•°å­—åŒ–è½¬å‹çš„æ·±å…¥ï¼Œæ•°æ®å®‰å…¨å¨èƒæ—¥ç›Šä¸¥å³»ã€‚ç»ˆç«¯è®¾å¤‡ä½œä¸ºæ•°æ®æµè½¬çš„å…³é”®èŠ‚ç‚¹ï¼Œé¢ä¸´ç€å†…éƒ¨æ³„éœ²ã€å¤–éƒ¨æ”»å‡»ç­‰å¤šé‡é£é™©ã€‚æœ¬é¡¹ç›®æ—¨åœ¨æ„å»ºä¸€å¥—å®Œæ•´çš„ç»ˆç«¯æ•°æ®é˜²æ³„æ¼ç³»ç»Ÿï¼Œå®ç°å¯¹æ•æ„Ÿæ•°æ®çš„å…¨ç”Ÿå‘½å‘¨æœŸä¿æŠ¤ã€‚

### 1.2 é¡¹ç›®ç›®æ ‡
- **æ•°æ®è¯†åˆ«**: è‡ªåŠ¨è¯†åˆ«å’Œåˆ†ç±»æ•æ„Ÿæ•°æ®ï¼Œæ”¯æŒå¤šç§æ•°æ®æ ¼å¼å’Œå†…å®¹ç±»å‹
- **è¡Œä¸ºç›‘æ§**: å®æ—¶ç›‘æ§æ•°æ®è®¿é—®å’Œä¼ è¾“è¡Œä¸ºï¼Œè¦†ç›–ç½‘ç»œã€æ–‡ä»¶ã€åº”ç”¨ç­‰å¤šä¸ªç»´åº¦
- **é£é™©æ§åˆ¶**: åŸºäºç­–ç•¥çš„è‡ªåŠ¨åŒ–é£é™©æ§åˆ¶ï¼Œæ”¯æŒé˜»æ–­ã€å‘Šè­¦ã€å®¡è®¡ç­‰å¤šç§å“åº”æ–¹å¼
- **åˆè§„å®¡è®¡**: æ»¡è¶³æ³•è§„è¦æ±‚çš„å®¡è®¡è¿½æº¯èƒ½åŠ›ï¼Œç¡®ä¿æ•°æ®å¤„ç†çš„åˆè§„æ€§

### 1.3 æ ¸å¿ƒç‰¹æ€§
- ğŸ”’ **é›¶ä¿¡ä»»æ¶æ„**: é»˜è®¤æ‹’ç»ï¼ŒåŸºäºç­–ç•¥çš„ç²¾ç»†åŒ–æ§åˆ¶
- ğŸš€ **é«˜æ€§èƒ½å¤„ç†**: æ”¯æŒGbpsçº§åˆ«çš„æµé‡å¤„ç†èƒ½åŠ›
- ğŸ”§ **æ’ä»¶åŒ–è®¾è®¡**: æ¨¡å—åŒ–æ¶æ„ï¼Œæ”¯æŒåŠŸèƒ½æ‰©å±•å’Œå®šåˆ¶åŒ–å¼€å‘
- ğŸŒ **è·¨å¹³å°æ”¯æŒ**: Windowsã€macOSã€Linuxå…¨å¹³å°è¦†ç›–
- ğŸ“Š **æ™ºèƒ½åˆ†æ**: åŸºäºæœºå™¨å­¦ä¹ çš„å¼‚å¸¸è¡Œä¸ºæ£€æµ‹å’Œå¨èƒè¯†åˆ«
- ğŸ›¡ï¸ **å¤šå±‚é˜²æŠ¤**: ç½‘ç»œå±‚ã€åº”ç”¨å±‚ã€æ–‡ä»¶å±‚çš„å…¨æ–¹ä½é˜²æŠ¤
- âš¡ **å®æ—¶å“åº”**: æ¯«ç§’çº§çš„å¨èƒæ£€æµ‹å’Œå“åº”èƒ½åŠ›

### 1.4 åº”ç”¨åœºæ™¯
- **ä¼ä¸šå†…ç½‘å®‰å…¨**: é˜²æ­¢æ•æ„Ÿæ•°æ®é€šè¿‡ç½‘ç»œæ¸ é“æ³„éœ²
- **ç»ˆç«¯è®¾å¤‡ç®¡æ§**: æ§åˆ¶USBã€æ‰“å°æœºç­‰å¤–è®¾çš„æ•°æ®ä¼ è¾“
- **åº”ç”¨è¡Œä¸ºç›‘æ§**: ç›‘æ§åŠå…¬è½¯ä»¶ã€æµè§ˆå™¨ç­‰åº”ç”¨çš„æ•°æ®æ“ä½œ
- **åˆè§„æ€§å®¡è®¡**: æ»¡è¶³GDPRã€ç­‰ä¿ç­‰æ³•è§„è¦æ±‚çš„å®¡è®¡éœ€æ±‚

---

## 2. éœ€æ±‚åˆ†æ

### 2.1 åŠŸèƒ½éœ€æ±‚

#### 2.1.1 æ•°æ®è¯†åˆ«ä¸åˆ†ç±»
- **å†…å®¹è¯†åˆ«**:
  - æ”¯æŒæ–‡æ¡£(DOC/DOCX/PDF/TXT)ã€å›¾ç‰‡(JPG/PNG/BMP)ã€ä»£ç æ–‡ä»¶ç­‰å¤šç§æ ¼å¼
  - æ”¯æŒå‹ç¼©åŒ…å†…å®¹çš„é€’å½’æ‰«æ
  - æ”¯æŒåŠ å¯†æ–‡ä»¶çš„è§£å¯†åˆ†æ(åœ¨æˆæƒæƒ…å†µä¸‹)
- **æ•æ„Ÿä¿¡æ¯æ£€æµ‹**:
  - èº«ä»½è¯å·ã€é“¶è¡Œå¡å·ã€æ‰‹æœºå·ç­‰PIIä¿¡æ¯
  - ä¼ä¸šå†…éƒ¨ç¼–å·ã€é¡¹ç›®ä»£ç ç­‰è‡ªå®šä¹‰æ•æ„Ÿä¿¡æ¯
  - åŸºäºæ­£åˆ™è¡¨è¾¾å¼å’Œæœºå™¨å­¦ä¹ æ¨¡å‹çš„æ™ºèƒ½è¯†åˆ«
- **æ•°æ®åˆ†çº§**:
  - å…¬å¼€ã€å†…éƒ¨ã€æœºå¯†ã€ç»å¯†å››çº§åˆ†ç±»ä½“ç³»
  - æ”¯æŒè‡ªå®šä¹‰åˆ†çº§æ ‡å‡†å’Œæ ‡ç­¾ä½“ç³»
  - åŸºäºå†…å®¹ã€æ¥æºã€ç”¨æˆ·ç­‰å¤šç»´åº¦çš„è‡ªåŠ¨åˆ†çº§

#### 2.1.2 è¡Œä¸ºç›‘æ§
- **ç½‘ç»œæµé‡ç›‘æ§**:
  - HTTP/HTTPSã€FTPã€SMTP/POP3/IMAPã€SSHç­‰åè®®
  - æ”¯æŒæ·±åº¦åŒ…æ£€æµ‹(DPI)å’Œæµé‡é‡ç»„
  - å®æ—¶æµé‡åˆ†æå’Œå¼‚å¸¸æ£€æµ‹
- **æ–‡ä»¶æ“ä½œå®¡è®¡**:
  - æ–‡ä»¶çš„åˆ›å»ºã€ä¿®æ”¹ã€åˆ é™¤ã€å¤åˆ¶ã€ç§»åŠ¨æ“ä½œ
  - æ–‡ä»¶æƒé™å˜æ›´å’Œå…±äº«æ“ä½œ
  - æ”¯æŒæ–‡ä»¶æŒ‡çº¹å’Œç‰ˆæœ¬è¿½è¸ª
- **åº”ç”¨è¡Œä¸ºç›‘æ§**:
  - æµè§ˆå™¨ä¸‹è½½ã€ä¸Šä¼ è¡Œä¸º
  - åŠå…¬è½¯ä»¶çš„æ–‡æ¡£æ“ä½œ
  - å³æ—¶é€šè®¯å·¥å…·çš„æ–‡ä»¶ä¼ è¾“
  - äº‘ç›˜åŒæ­¥å’Œé‚®ä»¶å‘é€è¡Œä¸º
- **å¤–è®¾æ§åˆ¶**:
  - USBå­˜å‚¨è®¾å¤‡çš„è¯»å†™æ§åˆ¶
  - æ‰“å°æœºçš„æ‰“å°å†…å®¹ç›‘æ§
  - è“ç‰™è®¾å¤‡çš„æ•°æ®ä¼ è¾“æ§åˆ¶
  - å…‰é©±å’Œè½¯é©±çš„è®¿é—®æ§åˆ¶

#### 2.1.3 ç­–ç•¥ç®¡ç†
- **åˆ†çº§ç­–ç•¥**:
  - æ”¯æŒå…¨å±€ã€éƒ¨é—¨ã€ç”¨æˆ·ä¸‰çº§ç­–ç•¥ä½“ç³»
  - ç­–ç•¥ç»§æ‰¿å’Œè¦†ç›–æœºåˆ¶
  - ç­–ç•¥ä¼˜å…ˆçº§å’Œå†²çªè§£å†³
- **åŠ¨æ€æ›´æ–°**:
  - ç­–ç•¥çƒ­æ›´æ–°ï¼Œæ— éœ€é‡å¯æœåŠ¡
  - ç‰ˆæœ¬æ§åˆ¶å’Œå›æ»šæœºåˆ¶
  - ç­–ç•¥å˜æ›´çš„å®¡è®¡è¿½è¸ª
- **æ¡ä»¶åŒ¹é…**:
  - åŸºäºç”¨æˆ·èº«ä»½ã€è§’è‰²ã€éƒ¨é—¨çš„æ¡ä»¶åŒ¹é…
  - åŸºäºæ—¶é—´ã€åœ°ç‚¹ã€ç½‘ç»œç¯å¢ƒçš„æ¡ä»¶åŒ¹é…
  - åŸºäºè®¾å¤‡ç±»å‹ã€åº”ç”¨ç¨‹åºçš„æ¡ä»¶åŒ¹é…
- **åŠ¨ä½œæ‰§è¡Œ**:
  - é˜»æ–­: å®Œå…¨ç¦æ­¢æ“ä½œ
  - å‘Šè­¦: å‘é€é€šçŸ¥ä½†å…è®¸æ“ä½œ
  - å®¡è®¡: è®°å½•è¯¦ç»†æ—¥å¿—
  - åŠ å¯†: å¼ºåˆ¶åŠ å¯†ä¼ è¾“æˆ–å­˜å‚¨
  - æ°´å°: æ·»åŠ æ•°å­—æ°´å°æ ‡è¯†

### 2.2 éåŠŸèƒ½éœ€æ±‚

#### 2.2.1 æ€§èƒ½è¦æ±‚
- **ååé‡**: æ”¯æŒ10Gbpsç½‘ç»œæµé‡å¤„ç†ï¼Œæ»¡è¶³é«˜é€Ÿç½‘ç»œç¯å¢ƒéœ€æ±‚
- **å»¶è¿Ÿ**: ç½‘ç»œå»¶è¿Ÿå¢åŠ ä¸è¶…è¿‡5msï¼Œç¡®ä¿ç”¨æˆ·ä½“éªŒä¸å—å½±å“
- **å¹¶å‘**: æ”¯æŒ10ä¸‡å¹¶å‘è¿æ¥ï¼Œæ»¡è¶³å¤§å‹ä¼ä¸šçš„å¹¶å‘éœ€æ±‚
- **èµ„æºå ç”¨**:
  - å†…å­˜å ç”¨ä¸è¶…è¿‡512MB
  - CPUå ç”¨ç‡åœ¨æ­£å¸¸è´Ÿè½½ä¸‹ä¸è¶…è¿‡10%
  - ç£ç›˜I/Oä¼˜åŒ–ï¼Œé¿å…å½±å“ç³»ç»Ÿæ€§èƒ½

#### 2.2.2 å¯é æ€§è¦æ±‚
- **å¯ç”¨æ€§**: 99.9%ç³»ç»Ÿå¯ç”¨æ€§ï¼Œå¹´åœæœºæ—¶é—´ä¸è¶…è¿‡8.76å°æ—¶
- **æ•…éšœæ¢å¤**: 30ç§’å†…è‡ªåŠ¨æ•…éšœæ¢å¤ï¼Œæ”¯æŒçƒ­å¤‡å’Œæ•…éšœè½¬ç§»
- **æ•°æ®å®Œæ•´æ€§**: å®¡è®¡æ—¥å¿—é›¶ä¸¢å¤±ï¼Œæ”¯æŒæ•°æ®æ ¡éªŒå’Œæ¢å¤
- **å®¹é”™èƒ½åŠ›**:
  - å•ç‚¹æ•…éšœä¸å½±å“æ•´ä½“åŠŸèƒ½
  - æ”¯æŒé™çº§è¿è¡Œæ¨¡å¼
  - å¼‚å¸¸æƒ…å†µä¸‹çš„å®‰å…¨å¤±æ•ˆæœºåˆ¶

#### 2.2.3 å®‰å…¨è¦æ±‚
- **æ•°æ®åŠ å¯†**:
  - ä¼ è¾“æ•°æ®ä½¿ç”¨TLS 1.3åŠ å¯†
  - å­˜å‚¨æ•°æ®ä½¿ç”¨AES-256åŠ å¯†
  - å¯†é’¥ç®¡ç†å’Œè½®æ¢æœºåˆ¶
- **èº«ä»½è®¤è¯**:
  - æ”¯æŒå¤šå› å­èº«ä»½è®¤è¯(MFA)
  - é›†æˆä¼ä¸šAD/LDAPç³»ç»Ÿ
  - æ”¯æŒè¯ä¹¦è®¤è¯å’Œç”Ÿç‰©è¯†åˆ«
- **æƒé™æ§åˆ¶**:
  - åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶(RBAC)
  - æœ€å°æƒé™åŸåˆ™
  - æƒé™å®¡è®¡å’Œå®šæœŸè¯„ä¼°
- **å®¡è®¡è¿½æº¯**:
  - å®Œæ•´çš„æ“ä½œå®¡è®¡é“¾
  - ä¸å¯ç¯¡æ”¹çš„æ—¥å¿—è®°å½•
  - æ”¯æŒæ³•åŠ¡å–è¯è¦æ±‚

#### 2.2.4 å¯æ‰©å±•æ€§è¦æ±‚
- **æ°´å¹³æ‰©å±•**: æ”¯æŒé›†ç¾¤éƒ¨ç½²å’Œè´Ÿè½½å‡è¡¡
- **å‚ç›´æ‰©å±•**: æ”¯æŒç¡¬ä»¶èµ„æºçš„åŠ¨æ€è°ƒæ•´
- **åŠŸèƒ½æ‰©å±•**: æ’ä»¶åŒ–æ¶æ„æ”¯æŒåŠŸèƒ½æ¨¡å—çš„åŠ¨æ€åŠ è½½
- **åè®®æ‰©å±•**: æ”¯æŒæ–°åè®®å’Œæ•°æ®æ ¼å¼çš„å¿«é€Ÿé€‚é…

---

## 3. ç³»ç»Ÿæ¶æ„è®¾è®¡

### 3.1 æ•´ä½“æ¶æ„è®¾è®¡

#### 3.1.1 åˆ†å±‚æ¶æ„å›¾
```mermaid
graph TB
    subgraph "ç”¨æˆ·å±‚"
        A[ç»ˆç«¯åº”ç”¨ç¨‹åº]
        B[æµè§ˆå™¨]
        C[åŠå…¬è½¯ä»¶]
        D[å³æ—¶é€šè®¯]
    end

    subgraph "DLPå®¢æˆ·ç«¯"
        E[æµé‡æ‹¦æˆªå±‚]
        F[åè®®è§£æå¼•æ“]
        G[å†…å®¹åˆ†æå¼•æ“]
        H[ç­–ç•¥å†³ç­–å¼•æ“]
        I[åŠ¨ä½œæ‰§è¡Œå±‚]
        J[æœ¬åœ°å­˜å‚¨]
    end

    subgraph "ç®¡ç†å¹³å°"
        K[ç­–ç•¥ç®¡ç†ä¸­å¿ƒ]
        L[å®¡è®¡åˆ†æå¹³å°]
        M[å¨èƒæƒ…æŠ¥ä¸­å¿ƒ]
        N[ç”¨æˆ·ç®¡ç†ç³»ç»Ÿ]
    end

    subgraph "åŸºç¡€è®¾æ–½"
        O[ä»£ç†èŠ‚ç‚¹æ± ]
        P[æ—¥å¿—å­˜å‚¨é›†ç¾¤]
        Q[é…ç½®ä¸­å¿ƒ]
        R[æ¶ˆæ¯é˜Ÿåˆ—]
    end

    A --> E
    B --> E
    C --> E
    D --> E
    E --> F
    F --> G
    G --> H
    H --> I
    I --> O
    I --> J

    K --> H
    L --> P
    M --> H
    N --> K
    Q --> H
    R --> L
```

#### 3.1.2 æ’ä»¶åŒ–æ¶æ„è®¾è®¡
```go
// æ’ä»¶æ¥å£å®šä¹‰
type DLPPlugin interface {
    // æ’ä»¶åŸºæœ¬ä¿¡æ¯
    Name() string
    Version() string
    Description() string
    Dependencies() []string

    // ç”Ÿå‘½å‘¨æœŸç®¡ç†
    Initialize(config PluginConfig) error
    Start() error
    Stop() error
    Cleanup() error
    HealthCheck() error

    // åŠŸèƒ½æ¥å£
    ProcessData(data *DataContext) (*ProcessResult, error)
    GetMetrics() map[string]interface{}
    UpdateConfig(config PluginConfig) error

    // äº‹ä»¶å¤„ç†
    OnEvent(event *PluginEvent) error
}

// æ’ä»¶ç®¡ç†å™¨
type PluginManager struct {
    plugins     map[string]DLPPlugin
    config      *PluginManagerConfig
    logger      logging.Logger
    eventBus    *EventBus
    healthCheck *HealthChecker
}

func (pm *PluginManager) LoadPlugin(path string) error {
    // æ’ä»¶å®‰å…¨æ£€æŸ¥
    if err := pm.validatePlugin(path); err != nil {
        return fmt.Errorf("plugin validation failed: %w", err)
    }

    // åŠ¨æ€åŠ è½½æ’ä»¶
    plugin, err := plugin.Open(path)
    if err != nil {
        return fmt.Errorf("failed to open plugin: %w", err)
    }

    // è·å–æ’ä»¶å®ä¾‹
    symbol, err := plugin.Lookup("NewPlugin")
    if err != nil {
        return fmt.Errorf("plugin entry point not found: %w", err)
    }

    newPlugin := symbol.(func() DLPPlugin)
    dlpPlugin := newPlugin()

    // æ£€æŸ¥ä¾èµ–
    if err := pm.checkDependencies(dlpPlugin); err != nil {
        return fmt.Errorf("dependency check failed: %w", err)
    }

    // æ³¨å†Œæ’ä»¶
    pm.plugins[dlpPlugin.Name()] = dlpPlugin

    // åˆå§‹åŒ–æ’ä»¶
    pluginConfig := pm.config.GetPluginConfig(dlpPlugin.Name())
    if err := dlpPlugin.Initialize(pluginConfig); err != nil {
        delete(pm.plugins, dlpPlugin.Name())
        return fmt.Errorf("plugin initialization failed: %w", err)
    }

    // å¯åŠ¨å¥åº·æ£€æŸ¥
    pm.healthCheck.AddPlugin(dlpPlugin)

    pm.logger.Info("Plugin loaded successfully",
        "name", dlpPlugin.Name(),
        "version", dlpPlugin.Version())

    return nil
}
```

### 3.2 æ ¸å¿ƒç»„ä»¶æ¶æ„

#### 3.2.1 æ•°æ®æµå¤„ç†ç®¡é“
```mermaid
graph LR
    A[åŸå§‹æ•°æ®] --> B[æ•°æ®é¢„å¤„ç†]
    B --> C[åè®®è§£æ]
    C --> D[å†…å®¹æå–]
    D --> E[æ•æ„Ÿä¿¡æ¯è¯†åˆ«]
    E --> F[ç­–ç•¥åŒ¹é…]
    F --> G[é£é™©è¯„ä¼°]
    G --> H[åŠ¨ä½œæ‰§è¡Œ]
    H --> I[å®¡è®¡è®°å½•]

    subgraph "å¤„ç†é˜¶æ®µ"
        B
        C
        D
        E
    end

    subgraph "å†³ç­–é˜¶æ®µ"
        F
        G
    end

    subgraph "æ‰§è¡Œé˜¶æ®µ"
        H
        I
    end
```

#### 3.2.2 æ•°æ®æµè½¬æ—¶åºå›¾
```mermaid
sequenceDiagram
    participant App as åº”ç”¨ç¨‹åº
    participant Intercept as æµé‡æ‹¦æˆªå±‚
    participant Parser as åè®®è§£æå™¨
    participant Analyzer as å†…å®¹åˆ†æå™¨
    participant Engine as ç­–ç•¥å¼•æ“
    participant Action as åŠ¨ä½œæ‰§è¡Œå™¨
    participant Audit as å®¡è®¡ç³»ç»Ÿ
    participant Cloud as äº‘ç«¯ç®¡ç†

    App->>+Intercept: å‘èµ·ç½‘ç»œè¯·æ±‚
    Intercept->>+Parser: åŸå§‹æ•°æ®åŒ…
    Parser->>+Analyzer: è§£æåçš„æ•°æ®
    Analyzer->>Analyzer: æ•æ„Ÿä¿¡æ¯è¯†åˆ«
    Analyzer->>+Engine: å†…å®¹åˆ†æç»“æœ
    Engine->>Cloud: æŸ¥è¯¢æœ€æ–°ç­–ç•¥
    Cloud-->>Engine: è¿”å›ç­–ç•¥ä¿¡æ¯
    Engine->>Engine: ç­–ç•¥åŒ¹é…ä¸é£é™©è¯„ä¼°
    Engine->>+Action: æ‰§è¡Œå†³ç­–
    Action->>Audit: è®°å½•å®¡è®¡æ—¥å¿—
    Action->>Cloud: ä¸ŠæŠ¥å®‰å…¨äº‹ä»¶
    Action-->>-App: è¿”å›å¤„ç†ç»“æœ
```

### 3.3 æŠ€æœ¯é€‰å‹

#### 3.3.1 æ ¸å¿ƒæŠ€æœ¯æ ˆ
| ç»„ä»¶ | æŠ€æœ¯é€‰å‹ | ç‰ˆæœ¬è¦æ±‚ | é€‰æ‹©ç†ç”± |
|------|----------|----------|----------|
| å¼€å‘è¯­è¨€ | Go | 1.21+ | é«˜æ€§èƒ½ã€è·¨å¹³å°ã€ä¸°å¯Œçš„ç½‘ç»œåº“ |
| æµé‡æ‹¦æˆª | WinDivert(Windows)<br>PF(macOS)<br>Netfilter(Linux) | æœ€æ–°ç¨³å®šç‰ˆ | ç³»ç»Ÿçº§æµé‡æ§åˆ¶èƒ½åŠ› |
| åè®®è§£æ | gopacket | v1.1.19+ | æˆç†Ÿçš„åŒ…è§£æåº“ |
| TLSå¤„ç† | uTLS | v1.5+ | TLSæŒ‡çº¹ä¼ªè£…èƒ½åŠ› |
| æ•°æ®å­˜å‚¨ | SQLite/PostgreSQL | 3.36+/13+ | è½»é‡çº§æœ¬åœ°å­˜å‚¨/ä¼ä¸šçº§å­˜å‚¨ |
| ç¼“å­˜ç³»ç»Ÿ | Redis | 7.0+ | é«˜æ€§èƒ½å†…å­˜ç¼“å­˜ |
| æ¶ˆæ¯é˜Ÿåˆ— | NATS | v2.9+ | è½»é‡çº§ã€é«˜æ€§èƒ½æ¶ˆæ¯ä¼ é€’ |
| é…ç½®ç®¡ç† | Viper | v1.15+ | çµæ´»çš„é…ç½®ç®¡ç† |
| æ—¥å¿—ç³»ç»Ÿ | è‡ªç ”loggingåŒ… | - | ç»Ÿä¸€çš„æ—¥å¿—æ¥å£ |
| æœºå™¨å­¦ä¹  | TensorFlow Lite | v2.13+ | è½»é‡çº§MLæ¨ç†å¼•æ“ |
| åŠ å¯†ç®—æ³• | AES-256-GCM<br>ChaCha20-Poly1305 | - | é«˜å®‰å…¨æ€§åŠ å¯†ç®—æ³• |

#### 3.3.2 æ¶æ„æ¨¡å¼
- **æ’ä»¶åŒ–æ¶æ„**: æ”¯æŒåŠŸèƒ½æ¨¡å—çš„åŠ¨æ€åŠ è½½å’Œå¸è½½
- **äº‹ä»¶é©±åŠ¨**: åŸºäºäº‹ä»¶çš„å¼‚æ­¥å¤„ç†æ¨¡å¼
- **ç®¡é“æ¨¡å¼**: æ•°æ®å¤„ç†æµæ°´çº¿è®¾è®¡
- **ç­–ç•¥æ¨¡å¼**: å¯é…ç½®çš„è§„åˆ™å¼•æ“
- **è§‚å¯Ÿè€…æ¨¡å¼**: å®¡è®¡å’Œç›‘æ§åŠŸèƒ½
- **å·¥å‚æ¨¡å¼**: è·¨å¹³å°ç»„ä»¶åˆ›å»º
- **é€‚é…å™¨æ¨¡å¼**: ä¸åŒåè®®å’Œæ ¼å¼çš„ç»Ÿä¸€å¤„ç†

---

## 4. æ ¸å¿ƒæ¨¡å—è®¾è®¡

### 4.1 æµé‡æ‹¦æˆªå±‚è®¾è®¡

#### 4.1.1 è·¨å¹³å°æ‹¦æˆªæ¥å£
```go
// ç»Ÿä¸€çš„æµé‡æ‹¦æˆªæ¥å£
type TrafficInterceptor interface {
    // åˆå§‹åŒ–æ‹¦æˆªå™¨
    Initialize(config InterceptorConfig) error

    // å¯åŠ¨æµé‡æ‹¦æˆª
    Start() error

    // åœæ­¢æµé‡æ‹¦æˆª
    Stop() error

    // è®¾ç½®è¿‡æ»¤è§„åˆ™
    SetFilter(filter string) error

    // è·å–æ•°æ®åŒ…é€šé“
    GetPacketChannel() <-chan *PacketInfo

    // é‡æ–°æ³¨å…¥æ•°æ®åŒ…
    Reinject(packet *PacketInfo) error

    // è·å–ç»Ÿè®¡ä¿¡æ¯
    GetStats() InterceptorStats

    // å¥åº·æ£€æŸ¥
    HealthCheck() error
}

// æ•°æ®åŒ…ä¿¡æ¯ç»“æ„
type PacketInfo struct {
    ID          string
    Timestamp   time.Time
    Direction   PacketDirection
    Protocol    Protocol
    SourceIP    net.IP
    DestIP      net.IP
    SourcePort  uint16
    DestPort    uint16
    Payload     []byte
    Size        int
    Metadata    map[string]interface{}
    ProcessInfo *ProcessInfo
}

// è¿›ç¨‹ä¿¡æ¯
type ProcessInfo struct {
    PID         int
    ProcessName string
    ExecutePath string
    User        string
    CommandLine string
}

// æ‹¦æˆªå™¨ç»Ÿè®¡ä¿¡æ¯
type InterceptorStats struct {
    PacketsProcessed uint64
    PacketsDropped   uint64
    PacketsReinject  uint64
    BytesProcessed   uint64
    ErrorCount       uint64
    LastError        error
    StartTime        time.Time
    Uptime          time.Duration
}

// æ‹¦æˆªå™¨å·¥å‚
func NewTrafficInterceptor(platform string) (TrafficInterceptor, error) {
    switch platform {
    case "windows":
        return NewWinDivertInterceptor(), nil
    case "darwin":
        return NewPFInterceptor(), nil
    case "linux":
        return NewNetfilterInterceptor(), nil
    default:
        return nil, fmt.Errorf("unsupported platform: %s", platform)
    }
}
```

#### 4.1.2 Windowså®ç°ï¼ˆWinDivertï¼‰
```go
type WinDivertInterceptor struct {
    handle       C.HANDLE
    filter       string
    buffer       []byte
    packetCh     chan *PacketInfo
    stopCh       chan struct{}
    stats        InterceptorStats
    logger       logging.Logger
    processCache *ProcessCache
    config       InterceptorConfig
}

func (w *WinDivertInterceptor) Initialize(config InterceptorConfig) error {
    w.config = config
    w.filter = config.Filter
    w.buffer = make([]byte, config.BufferSize)
    w.packetCh = make(chan *PacketInfo, config.ChannelSize)
    w.stopCh = make(chan struct{})
    w.logger = config.Logger
    w.processCache = NewProcessCache(config.CacheSize)

    // æ‰“å¼€WinDivertå¥æŸ„
    handle := C.WinDivertOpen(
        C.CString(w.filter),
        C.WINDIVERT_LAYER_NETWORK,
        C.INT16(config.Priority),
        C.UINT64(config.Flags))

    if handle == C.INVALID_HANDLE_VALUE {
        return fmt.Errorf("failed to open WinDivert handle: %v", C.GetLastError())
    }

    w.handle = handle
    w.stats.StartTime = time.Now()

    // è®¾ç½®é˜Ÿåˆ—é•¿åº¦å’Œæ—¶é—´é™åˆ¶
    C.WinDivertSetParam(handle, C.WINDIVERT_PARAM_QUEUE_LEN, C.UINT64(config.QueueLen))
    C.WinDivertSetParam(handle, C.WINDIVERT_PARAM_QUEUE_TIME, C.UINT64(config.QueueTime))

    return nil
}

func (w *WinDivertInterceptor) Start() error {
    // å¯åŠ¨å¤šä¸ªå·¥ä½œåç¨‹æé«˜æ€§èƒ½
    for i := 0; i < w.config.WorkerCount; i++ {
        go w.captureWorker(i)
    }

    w.logger.Info("WinDivert interceptor started",
        "workers", w.config.WorkerCount,
        "filter", w.filter)
    return nil
}

func (w *WinDivertInterceptor) captureWorker(workerID int) {
    buffer := make([]byte, w.config.BufferSize)

    for {
        select {
        case <-w.stopCh:
            return
        default:
            var recvLen C.UINT
            var addr C.WINDIVERT_ADDRESS

            ret := C.WinDivertRecv(
                w.handle,
                unsafe.Pointer(&buffer[0]),
                C.UINT(len(buffer)),
                &recvLen,
                &addr)

            if ret == 0 {
                if err := C.GetLastError(); err != C.ERROR_INSUFFICIENT_BUFFER {
                    w.stats.ErrorCount++
                    w.stats.LastError = fmt.Errorf("WinDivertRecv failed: %v", err)
                }
                continue
            }

            // è§£ææ•°æ®åŒ…
            packet := w.parsePacket(buffer[:recvLen], &addr, workerID)
            if packet != nil {
                atomic.AddUint64(&w.stats.PacketsProcessed, 1)
                atomic.AddUint64(&w.stats.BytesProcessed, uint64(packet.Size))

                select {
                case w.packetCh <- packet:
                case <-w.stopCh:
                    return
                default:
                    // é€šé“æ»¡äº†ï¼Œä¸¢å¼ƒæ•°æ®åŒ…
                    atomic.AddUint64(&w.stats.PacketsDropped, 1)
                    w.logger.Warn("Packet channel full, dropping packet")
                }
            }
        }
    }
}

func (w *WinDivertInterceptor) parsePacket(data []byte, addr *C.WINDIVERT_ADDRESS, workerID int) *PacketInfo {
    // è§£æIPå¤´
    if len(data) < 20 {
        return nil
    }

    ipVersion := data[0] >> 4
    if ipVersion != 4 && ipVersion != 6 {
        return nil
    }

    packet := &PacketInfo{
        ID:        fmt.Sprintf("%d-%d-%d", workerID, time.Now().UnixNano(), addr.IfIdx),
        Timestamp: time.Now(),
        Payload:   make([]byte, len(data)),
        Size:      len(data),
        Metadata:  make(map[string]interface{}),
    }

    copy(packet.Payload, data)

    // è®¾ç½®æ–¹å‘
    if addr.Outbound != 0 {
        packet.Direction = PacketDirectionOutbound
    } else {
        packet.Direction = PacketDirectionInbound
    }

    // è§£æIPv4
    if ipVersion == 4 {
        packet.SourceIP = net.IP(data[12:16])
        packet.DestIP = net.IP(data[16:20])
        packet.Protocol = Protocol(data[9])

        // è§£æä¼ è¾“å±‚åè®®
        headerLen := int(data[0]&0x0F) * 4
        if headerLen >= 20 && len(data) > headerLen+4 {
            switch packet.Protocol {
            case ProtocolTCP:
                packet.SourcePort = binary.BigEndian.Uint16(data[headerLen:headerLen+2])
                packet.DestPort = binary.BigEndian.Uint16(data[headerLen+2:headerLen+4])
            case ProtocolUDP:
                packet.SourcePort = binary.BigEndian.Uint16(data[headerLen:headerLen+2])
                packet.DestPort = binary.BigEndian.Uint16(data[headerLen+2:headerLen+4])
            }
        }
    }

    // è·å–è¿›ç¨‹ä¿¡æ¯
    if processInfo := w.getProcessInfo(addr); processInfo != nil {
        packet.ProcessInfo = processInfo
    }

    return packet
}

func (w *WinDivertInterceptor) getProcessInfo(addr *C.WINDIVERT_ADDRESS) *ProcessInfo {
    // ä»ç¼“å­˜ä¸­è·å–è¿›ç¨‹ä¿¡æ¯
    if info := w.processCache.Get(addr.ProcessId); info != nil {
        return info
    }

    // æŸ¥è¯¢è¿›ç¨‹ä¿¡æ¯
    processInfo := &ProcessInfo{
        PID: int(addr.ProcessId),
    }

    // è·å–è¿›ç¨‹åç§°å’Œè·¯å¾„
    if handle := C.OpenProcess(C.PROCESS_QUERY_INFORMATION|C.PROCESS_VM_READ, 0, C.DWORD(addr.ProcessId)); handle != 0 {
        defer C.CloseHandle(handle)

        var buffer [C.MAX_PATH]C.WCHAR
        var size C.DWORD = C.MAX_PATH

        if C.QueryFullProcessImageNameW(handle, 0, &buffer[0], &size) != 0 {
            processInfo.ExecutePath = C.GoString((*C.char)(unsafe.Pointer(&buffer[0])))
            processInfo.ProcessName = filepath.Base(processInfo.ExecutePath)
        }
    }

    // ç¼“å­˜è¿›ç¨‹ä¿¡æ¯
    w.processCache.Set(addr.ProcessId, processInfo)

    return processInfo
}
```
```
